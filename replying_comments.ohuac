

ns wut;

use sf ohua::sql::query::{group_by, count, filter };
use sf ohua::lang::field;
use sf ohua::lang::field::{is_deleted, user_id, story_id, is_moderated, is_following, upvotes, downvotes,comment_id,parent_comment_id,created_at,reason,updated_at};
use sf ohua::lang::{eq, not, neq, and, geq,lt, or};

use sf some_ns::{append, Table};
use sf ohua;

#[ohua::noria_integration::make_udf]
fn my_lt(i : i64, j : i64) -> i32 {
    i32::from(std::cmp::PartialOrd::lt(&i, &j))
}

fn test(table : Stream<U>) -> Table<Result> {
    let t = Table::new();
    for x in table {
        t.append(x);
    };
    id(t)
}

fn main(ribbons: Stream<Ribbon>, stories: Stream<Story>, comments: Stream<Comment>, also_comments: Stream<Comment>, votes: Stream<Vote>) -> Table<Result> {
    for ribbon in ribbons.filter(|r| r.is_following) {
        let c1 = comments
            .filter(|c| eq(c.story_id, ribbon.story_id));
        let c2 = c1
            .filter(|c| neq(c.user_id, ribbon.user_id));
        let c3 = c2
            .filter(|c| and(not(c.is_deleted), not(c.is_moderated)));
        for comment in c3
            .filter(|x| geq(x.upvotes, x.downvotes))
        {

            let s1 = stories
                .filter(|s| eq(s.field::id, comment.story_id));

            // this should error of the target does not exist actually and it also should only return one
            for story in s1
                .filter(|x| geq(x.upvotes, x.downvotes))
            {
                // This should be None if no parent exists
                for parent in also_comments.filter(|c| eq(c.field::id, comment.parent_comment_id)) {

                    let v1 = votes
                        .filter(|v| and(eq(v.user_id, ribbon.user_id), eq(v.comment_id, comment.field::id)));
                    let v2 = v1
                        .filter(|v|
                        // Commented out because I need to check how noria does `or` conditions
                        // or(eq(parent.user_id, ribbon.user_id),
                                     eq(story.user_id, ribbon.user_id)
                        //    )
                                     );
                    for vote in v2
                        .filter(|v| geq(parent.upvotes, parent.downvotes))
                    {
                        ( ribbon.user_id,
                          comment.field::id,
                          ribbon.story_id,
                          comment.parent_comment_id,
                          comment.created_at,
                          parent.user_id,
                          comment.user_id,
                          story.user_id,
                          lt(ribbon.updated_at, comment.created_at),
                          vote.field::vote,
                          vote.reason
                        )
                    }
                }
            }
        }
    }
}

fn main0(ribbons: Stream<Ribbon>) -> Table<Result> {
    for ribbon in ribbons.filter(|r| r.is_following) {
        ribbon
    }
}

fn main1(ribbons: Stream<Ribbon>, comments: Stream<Comment>) -> Table<Result> {
    for ribbon in ribbons.filter(|r| r.is_following) {
        let c1 = comments
            .filter(|c| eq(c.story_id, ribbon.story_id));
        let c2 = c1
            .filter(|c| neq(c.user_id, ribbon.user_id));
        let c3 = c2
            .filter(|c| and(not(c.is_deleted), not(c.is_moderated)));
        for comment in c3
            .filter(|x| geq(x.upvotes, x.downvotes)) {
            comment
        }
    }
}
fn main2(ribbons: Stream<Ribbon>, stories: Stream<Story>,  comments: Stream<Comment>) -> Table<Result> {
    for ribbon in ribbons.filter(|r| r.is_following) {
        let c1 = comments
            .filter(|c| eq(c.story_id, ribbon.story_id));
        let c2 = c1
            .filter(|c| neq(c.user_id, ribbon.user_id));
        let c3 = c2
            .filter(|c| and(not(c.is_deleted), not(c.is_moderated)));
        for comment in c3
            .filter(|x| geq(x.upvotes, x.downvotes)) {

            let s1 = stories
                .filter(|s| eq(s.field::id, comment.story_id));

            // this should error of the target does not exist actually and it also should only return one
            for story in s1
                .filter(|x| geq(x.upvotes, x.downvotes)) {
                (story.field::id, story.downvotes, story.field::title, comment.field::comment, comment.created_at, ribbon.field::id)
            }
        }
    }
}

fn main4(ribbons: Stream<Ribbon>, stories: Stream<Story>,  comments: Stream<Comment>, also_comments: Stream<Comment>, votes: Stream<Vote>) -> Table<Result> {
    for ribbon in ribbons.filter(|r| r.is_following) {
        let c1 = comments
            .filter(|c| eq(c.story_id, ribbon.story_id));
        let c2 = c1
            .filter(|c| neq(c.user_id, ribbon.user_id));
        let c3 = c2
            .filter(|c| and(not(c.is_deleted), not(c.is_moderated)));
        for comment in c3
            .filter(|x| geq(x.upvotes, x.downvotes)) {

            let s1 = stories
                .filter(|s| eq(s.field::id, comment.story_id));

            // this should error of the target does not exist actually and it also should only return one
            for story in s1
                .filter(|x| geq(x.upvotes, x.downvotes)) {

                for parent in also_comments.filter(|c| eq(c.field::id, comment.parent_comment_id)) {

                    let v1 = votes
                        .filter(|v| and(eq(v.user_id, ribbon.user_id), eq(v.comment_id, comment.field::id)));
                    for vote in v1
                        .filter(|v| geq(parent.upvotes, parent.downvotes))
                    {
                        ( ribbon.user_id,
                          comment.field::id,
                          ribbon.story_id,
                          comment.parent_comment_id,
                          comment.created_at,
                          parent.user_id,
                          comment.user_id,
                          story.user_id,
                          lt(ribbon.updated_at, comment.created_at),
                          vote.field::vote,
                          vote.reason
                        )
                    }
                }
            }
        }
    }
}

#[ohua::noria_integration::make_udf]
fn or_cond(parent_user_id : i64, ribbon_user_id : i64, story_user_id : i64) -> i64 {
   if parent_user_id == ribbon_user_id {
       1
   } else if story_user_id == ribbon_user_id {
       1
   } else { 0 }
}

fn main5(ribbons: Stream<Ribbon>, stories: Stream<Story>, comments: Stream<Comment>, also_comments: Stream<Comment>, votes: Stream<Vote>) -> Table<Result> {
    for ribbon in ribbons.filter(|r| r.is_following) {
        let c1 = comments
            .filter(|c| eq(c.story_id, ribbon.story_id));
        let c2 = c1
            .filter(|c| neq(c.user_id, ribbon.user_id));
        let c3 = c2
            .filter(|c| and(not(c.is_deleted), not(c.is_moderated)));
        for comment in c3
            .filter(|x| geq(x.upvotes, x.downvotes))
        {

            let s1 = stories
                .filter(|s| eq(s.field::id, comment.story_id));

            // this should error of the target does not exist actually and it also should only return one
            for story in s1
                .filter(|x| geq(x.upvotes, x.downvotes))
            {
                // This should be None if no parent exists
                for parent in also_comments.filter(|c| eq(c.field::id, comment.parent_comment_id)) {

                    let v1 = votes
                        .filter(|v| and(eq(v.user_id, ribbon.user_id), eq(v.comment_id, comment.field::id)));
                    for vote in v1
                        .filter(|v| geq(parent.upvotes, parent.downvotes))
                    {
                        if or_cond(parent.user_id, ribbon.user_id, story.user_id) {
                            ( ribbon.user_id,
                              comment.field::id,
                              ribbon.story_id,
                              comment.parent_comment_id,
                              comment.created_at,
                              parent.user_id,
                              comment.user_id,
                              story.user_id,
                              lt(ribbon.updated_at, comment.created_at),
                              vote.field::vote,
                              vote.reason
                            )
                        }
                    }
                }
            }
        }
    }
}

fn main6() -> Table<Result> {
    for ribbon in ohua::sql::table::read_ribbons.filter(|r| r.is_following) {

        let c1 = ohua::sql::table::comment_with_votes
            .filter(|c| eq(c.story_id, ribbon.story_id));
        let c2 = c1
            .filter(|c| neq(c.user_id, ribbon.user_id));
        let c3 = c2
            .filter(|c| and(not(c.is_deleted), not(c.is_moderated)));
        for comment in c3
            .filter(|x| geq(x.upvotes, x.downvotes))
        {

            let s1 = ohua::sql::table::story_with_votes
                .filter(|s| eq(s.field::id, comment.story_id));

            // this should error of the target does not exist actually and it also should only return one
            for story in s1
                .filter(|x| geq(x.upvotes, x.downvotes))
            {
                // This should be None if no parent exists
                for parent in ohua::sql::table::parent_comments.filter(|c| eq(c.field::id, comment.parent_comment_id)) {

                    let v1 = ohua::sql::table::votes
                        .filter(|v| and(eq(v.user_id, ribbon.user_id), eq(v.comment_id, comment.field::id)));
                    for vote in v1
                        .filter(|v| geq(parent.upvotes, parent.downvotes))
                    {
                        if or_cond(parent.user_id, ribbon.user_id, story.user_id) {
                            ( ribbon.user_id,
                              comment.field::id,
                              ribbon.story_id,
                              comment.parent_comment_id,
                              comment.created_at,
                              parent.user_id,
                              comment.user_id,
                              story.user_id,
                              lt(ribbon.updated_at, comment.created_at),
                              vote.field::vote,
                              vote.reason
                            )
                        }
                    }
                }
            }
        }
    }
}

#[ohua::noria_integration::make_udf]
fn minus(a: i64, b: i64) -> i64 {
    std::ops::Sub::sub(a, b)
}

#[ohua::noria_integration::make_udf]
fn another_or_cond(puid: i64, ruid: i64, psaldo: i64, suid: i64) -> i64 {
    if ((puid == ruid) && (psaldo >= 0)) || (suid == ruid) {
        1
    } else {
        0
    }
}

fn BOUNDARY_replying_comments_for_count() {

    for ribbon in ohua::sql::table::read_ribbons.filter(|r| r.is_following) {

        for story in ohua::sql::table::stories.filter(|s| eq(s.field::id, ribbon.story_id)) {

            let c1 = ohua::sql::table::comments.filter(|c| eq(c.story_id, ribbon.story_id));
            let c2 = c1.filter(|c| eq(c.user_id, ribbon.user_id));
            let c3 = c2.filter(|c| not(or(c.is_deleted, c.is_moderated)));
            for comment in c3.filter(|c| lt(ribbon.updated_at, c.created_at)) {

                for parent in ohua::sql::table::parent_comments.filter(|p| eq(comment.parent_comment_id, p.field::id)) {

                    let saldo = minus(comment.upvotes, comment.downvotes);
                    let psaldo = minus(parent.upvotes, parent.downvotes);

                    if another_or_cond(parent.user_id, ribbon.user_id, psaldo, story.user_id) {
                        ( ribbon.user_id,
                          ribbon.story_id,
                          comment.field::id,
                          saldo,
                          psaldo
                        )
                    }
                }
            }
        }
    }
}

// fn BOUNDARY_notifications(uid : i64) -> Result {
//     let t = for (i, recs) in BOUNDARY_replying_comments_for_count().group_by(|r| r.user_id) {
//         (x.user_id, count(recs))
//     }

//     t.get(uid)
// }
